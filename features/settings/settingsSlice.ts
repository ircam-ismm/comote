import {
  createSlice,
  createAsyncThunk,
  createAction,
  Action,
  AnyAction,
  PayloadAction,
} from '@reduxjs/toolkit';
import type { RootState, AppThunk } from '../../store';

import {engine} from '../../engine';

interface SettingsState {
  data: any;
  status: 'idle' | 'loading' | 'error';
}

const initialState = {
  data: {
    id: 0,
    deviceMotionFrequency: 50, // in hertz (20ms)
    deviceMotionInterval: 20,  // in ms
    webSocketEnabled: false,
    webSocketUrl: null,
    oscEnabled: false,
    oscUrl: null,
  },
  status: 'idle',
} as SettingsState;

interface RejectedAction extends Action {
  error: Error
}

function isRejectedAction(action: AnyAction): action is RejectedAction {
  return action.type.endsWith('rejected')
}

const settingsSlice = createSlice({
  name: 'settings',
  initialState,
  reducers: {

    set: (state, action: PayloadAction<any>) => {
      Object.assign(state.data, action.payload);

      // replace empty value, undefined, NaN, or 0, with default value
      if (!Number.isInteger(state.data.deviceMotionFrequency)
        || state.data.deviceMotionFrequency <= 0
        || state.data.deviceMotionFrequency >= 200 // probably too high
      ) {
        state.data.deviceMotionFrequency = initialState.data.deviceMotionFrequency;
      }

      // keep `deviceMotionInterval` in sync with `deviceMotionFrequency`
      if ('deviceMotionFrequency' in action.payload) {
        // we use a rounded value because it is also used in `setInterval`
        // which get mad with floats
        state.data.deviceMotionInterval = Math.round(1000 / state.data.deviceMotionFrequency);
      }

      if (!Number.isInteger(state.data.id) || state.data.id < 0) {
        state.data.id = initialState.data.id;
      }

      // Be sure that protocol is in lower-case to avoid crash on android.
      // NetworkComponent later does URL verification
      if (typeof state.data.webSocketUrl === 'string') {
        const splitted = state.data.webSocketUrl.split('://');

        if (splitted && splitted.length > 1 && typeof splitted[0] === 'string') {
          splitted[0] = splitted[0].toLowerCase();
          state.data.webSocketUrl = splitted.join('://');
        }
      }

      if (typeof state.data.oscUrl === 'string') {
        const splitted = state.data.oscUrl.split('://');

        if (splitted && splitted.length > 1 && typeof splitted[0] === 'string') {
          splitted[0] = splitted[0].toLowerCase();
          state.data.oscUrl = splitted.join('://');
        }
      }
    },

  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      .addMatcher(isRejectedAction,
        // `action` will be inferred as a RejectedAction due to
        // isRejectedAction being defined as a type guard
        (state: SettingsState, action) => {
          state.status = 'error';
        }
      )
      // and provide a default case if no other handlers matched
      .addDefaultCase((state, action) => { });
  },
});

export const {
  set,
} = settingsSlice.actions;

// The function below is called a selector and allows us to select a data from
// the state. Selectors can also be defined inline where they're used instead of
// in the slice file.
export const selectSettings = (state: RootState) => {
  return state.settings.data;
}

export const selectDeviceMotionInterval = (state: RootState) => {
  return state.settings.data.deviceMotionInterval;
}

export default settingsSlice.reducer;
